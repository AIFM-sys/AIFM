<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="namespaces.html"><span>Namespace List</span></a></li>
    <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
  </ul></div>
<h1>tbb Namespace Reference</h1>The namespace tbb contains all components of the library.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">aligned_space</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block of space aligned sufficiently to construct an array T with N elements.  <a href="a00142.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">atomic</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Primary template for atomic.  <a href="a00143.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">atomic&lt; void * &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for <a class="el" href="a00144.html">atomic&lt;void*&gt;</a>, for sake of not allowing arithmetic or operator-&gt;.  <a href="a00144.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">blocked_range</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A range over which to iterate.  <a href="a00148.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">blocked_range2d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 2-dimensional range that models the Range concept.  <a href="a00149.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00150.html">blocked_range3d</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A 3-dimensional range that models the Range concept.  <a href="a00150.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">cache_aligned_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00151.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">cache_aligned_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00152.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">combinable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread-local storage with optional reduction.  <a href="a00154.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">tbb_hash_compare</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hash_compare that is default argument for concurrent_hash_map  <a href="a00208.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">concurrent_bounded_queue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A high-performance thread-safe blocking concurrent bounded queue.  <a href="a00155.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb_hash</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">concurrent_vector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concurrent vector container.  <a href="a00162.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html">mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper around the platform's native reader-writer lock.  <a href="a00172.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">null_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutex which does nothing.  <a href="a00174.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">null_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A rw mutex which does nothing.  <a href="a00176.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">parallel_do_feeder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class the user supplied algorithm body uses to add new tasks.  <a href="a00178.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">pre_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the initial scan is being performed.  <a href="a00181.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">final_scan_tag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to indicate that the final scan is being performed.  <a href="a00167.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">parallel_while</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a stream, with optional addition of more work.  <a href="a00179.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">simple_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple partitioner.  <a href="a00193.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">auto_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An auto partitioner.  <a href="a00146.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">affinity_partitioner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An affinity partitioner.  <a href="a00141.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline.  <a href="a00165.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">thread_bound_filter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stage in a pipeline served by a user thread.  <a href="a00209.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">pipeline</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A processing pipeling that applies filters to items.  <a href="a00180.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">queuing_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queuing lock with local-only spinning.  <a href="a00182.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">queuing_rw_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reader-writer lock with local-only spinning.  <a href="a00184.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">recursive_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mutex that allows recursive mutex acquisition.  <a href="a00189.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">scalable_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00191.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">scalable_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00192.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">spin_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A lock that occupies a single byte.  <a href="a00194.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">spin_rw_mutex_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast, unfair, spinning reader-writer lock with backoff and writer-preference.  <a href="a00196.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">task_group_context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to form groups of tasks.  <a href="a00201.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for user-defined tasks.  <a href="a00199.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00163.html">empty_task</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">task that does nothing. Useful for synchronization.  <a href="a00163.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html">task_list</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of children.  <a href="a00202.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_handle</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_group</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>structured_task_group</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">task_scheduler_init</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing reference to tbb scheduler.  <a href="a00203.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">tbb_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00204.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">tbb_allocator&lt; void &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00205.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">zero_allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets "allocator" requirements of ISO C++ Standard, Section 20.1.5.  <a href="a00213.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">zero_allocator&lt; void, Allocator &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analogous to std::allocator&lt;void&gt;, as defined in ISO C++ Standard, Section 20.4.1.  <a href="a00214.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">bad_last_alloc</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for concurrent containers.  <a href="a00147.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">improper_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for PPL locks.  <a href="a00168.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">missing_wait</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for missing wait on structured_task_group.  <a href="a00170.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html">invalid_multiple_scheduling</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception for repeated scheduling of the same task_handle.  <a href="a00169.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">tbb_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to be implemented by all exceptions TBB recognizes and propagates across the threads.  <a href="a00206.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">captured_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by TBB to propagate information about unhandled exceptions into the root thread.  <a href="a00153.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">movable_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template that can be used to implement exception that transfers arbitrary ExceptionData to the root thread.  <a href="a00171.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">split</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dummy type that distinguishes splitting constructor from copy constructor.  <a href="a00198.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">tick_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Absolute timestamp.  <a href="a00210.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00273.html">strict_ppl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>parallel_do</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_do_body_req.html">parallel_do Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3383e2703977012b6f384d673410f1f7"></a><!-- doxytag: member="tbb::parallel_do" ref="g3383e2703977012b6f384d673410f1f7" args="(Iterator first, Iterator last, const Body &amp;body)" -->
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g3383e2703977012b6f384d673410f1f7">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2617dc9b88b3285a7212599d49f74228"></a><!-- doxytag: member="tbb::parallel_do" ref="g2617dc9b88b3285a7212599d49f74228" args="(Iterator first, Iterator last, const Body &amp;body, task_group_context &amp;context)" -->
template&lt;typename Iterator, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g2617dc9b88b3285a7212599d49f74228">parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over a range, with optional addition of more work and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_for_body_req.html">parallel_for Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g68cc046ef72c42ce205fccbc435a0d81"></a><!-- doxytag: member="tbb::parallel_for" ref="g68cc046ef72c42ce205fccbc435a0d81" args="(const Range &amp;range, const Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g68cc046ef72c42ce205fccbc435a0d81">parallel_for</a> (const Range &amp;range, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g13cac5dd55c7533bccea43a51c33d0e5"></a><!-- doxytag: member="tbb::parallel_for" ref="g13cac5dd55c7533bccea43a51c33d0e5" args="(const Range &amp;range, const Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g13cac5dd55c7533bccea43a51c33d0e5">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00193.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga7ac75d532389b55b9247f3fdb0b00d1"></a><!-- doxytag: member="tbb::parallel_for" ref="ga7ac75d532389b55b9247f3fdb0b00d1" args="(const Range &amp;range, const Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#ga7ac75d532389b55b9247f3fdb0b00d1">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00146.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00146.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g9cd1b210ceb1c040f30e390b4a21bde8"></a><!-- doxytag: member="tbb::parallel_for" ref="g9cd1b210ceb1c040f30e390b4a21bde8" args="(const Range &amp;range, const Body &amp;body, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g9cd1b210ceb1c040f30e390b4a21bde8">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00141.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00141.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2d317a5e0078cd193125439fed60dfdc"></a><!-- doxytag: member="tbb::parallel_for" ref="g2d317a5e0078cd193125439fed60dfdc" args="(const Range &amp;range, const Body &amp;body, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g2d317a5e0078cd193125439fed60dfdc">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00193.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1c0700e3f85e83a788ff3ede88ebb7e9"></a><!-- doxytag: member="tbb::parallel_for" ref="g1c0700e3f85e83a788ff3ede88ebb7e9" args="(const Range &amp;range, const Body &amp;body, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g1c0700e3f85e83a788ff3ede88ebb7e9">parallel_for</a> (const Range &amp;range, const Body &amp;body, const <a class="el" href="a00146.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00146.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g04b4696b67370c01353ff5974c8f1196"></a><!-- doxytag: member="tbb::parallel_for" ref="g04b4696b67370c01353ff5974c8f1196" args="(const Range &amp;range, const Body &amp;body, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g04b4696b67370c01353ff5974c8f1196">parallel_for</a> (const Range &amp;range, const Body &amp;body, <a class="el" href="a00141.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration over range with <a class="el" href="a00141.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_for_each</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gcd40c32f319747e61a8f73fcfc452001"></a><!-- doxytag: member="tbb::parallel_for_each" ref="gcd40c32f319747e61a8f73fcfc452001" args="(InputIterator first, InputIterator last, const Function &amp;f, task_group_context &amp;context)" -->
template&lt;typename InputIterator, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gcd40c32f319747e61a8f73fcfc452001">parallel_for_each</a> (InputIterator first, InputIterator last, const Function &amp;f, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls function f for all items from [first, last) interval using user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc2d710ca573f0a9bd94379cba3772def"></a><!-- doxytag: member="tbb::parallel_for_each" ref="gc2d710ca573f0a9bd94379cba3772def" args="(InputIterator first, InputIterator last, const Function &amp;f)" -->
template&lt;typename InputIterator, typename Function&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gc2d710ca573f0a9bd94379cba3772def">parallel_for_each</a> (InputIterator first, InputIterator last, const Function &amp;f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uses default context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_invoke</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd3e2998f171494f94c2103f4eb924084"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gd3e2998f171494f94c2103f4eb924084" args="(const F0 &amp;f0, const F1 &amp;f1, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gd3e2998f171494f94c2103f4eb924084">parallel_invoke</a> (const F0 &amp;f0, const F1 &amp;f1, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Executes a list of tasks in parallel and waits for all tasks to complete. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g4eb73562e4145c8343ed9f996267f039"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g4eb73562e4145c8343ed9f996267f039" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd1335c4b54fbf8d3f5be6a5c255c8c60"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gd1335c4b54fbf8d3f5be6a5c255c8c60" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g40b88e3db7ecb09cbfe0230ea1c24030"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g40b88e3db7ecb09cbfe0230ea1c24030" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g98a8b388f7e0b7621a964a8c23752d1d"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g98a8b388f7e0b7621a964a8c23752d1d" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb95f31638bdde9d909361ad2e96a93eb"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gb95f31638bdde9d909361ad2e96a93eb" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1655b24786f010ee0a008907a07bb61d"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g1655b24786f010ee0a008907a07bb61d" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g105220f1c95f9888b696a3e47027527b"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g105220f1c95f9888b696a3e47027527b" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1ef1774e0fcc4f632fe0af2591781c4c"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g1ef1774e0fcc4f632fe0af2591781c4c" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9, tbb::task_group_context &amp;context)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9, <a class="el" href="a00201.html">tbb::task_group_context</a> &amp;context)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ge832d8ad8b246c884e3c897ed63f8216"></a><!-- doxytag: member="tbb::parallel_invoke" ref="ge832d8ad8b246c884e3c897ed63f8216" args="(const F0 &amp;f0, const F1 &amp;f1)" -->
template&lt;typename F0, typename F1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb91fec4e7ba49754ad583ccb127afc66"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gb91fec4e7ba49754ad583ccb127afc66" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2)" -->
template&lt;typename F0, typename F1, typename F2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g421d0f66ee69eea134a35d1ae371d8d6"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g421d0f66ee69eea134a35d1ae371d8d6" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3)" -->
template&lt;typename F0, typename F1, typename F2, typename F3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g8aacce74d691b4f44a0f7becadd9578c"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g8aacce74d691b4f44a0f7becadd9578c" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g8cc6994f7cd6eaf25feb5d7cc04a2e64"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g8cc6994f7cd6eaf25feb5d7cc04a2e64" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g995ba9583ae24bddb8bd9a599cc8b4c7"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g995ba9583ae24bddb8bd9a599cc8b4c7" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g34341a4c24c6f548886cd14077374c5c"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g34341a4c24c6f548886cd14077374c5c" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2a11342753488d460866d48370a69517"></a><!-- doxytag: member="tbb::parallel_invoke" ref="g2a11342753488d460866d48370a69517" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gffcf6835ceee43455f310352a3b4faa5"></a><!-- doxytag: member="tbb::parallel_invoke" ref="gffcf6835ceee43455f310352a3b4faa5" args="(const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9)" -->
template&lt;typename F0, typename F1, typename F2, typename F3, typename F4, typename F5, typename F6, typename F7, typename F8, typename F9&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_invoke</b> (const F0 &amp;f0, const F1 &amp;f1, const F2 &amp;f2, const F3 &amp;f3, const F4 &amp;f4, const F5 &amp;f5, const F6 &amp;f6, const F7 &amp;f7, const F8 &amp;f8, const F9 &amp;f9)</td></tr>

<tr><td colspan="2"><br><h2>parallel_reduce</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_reduce_body_req.html">parallel_reduce Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1b3d59c5eb62683c5754db6970392fa3"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g1b3d59c5eb62683c5754db6970392fa3" args="(const Range &amp;range, Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g1b3d59c5eb62683c5754db6970392fa3">parallel_reduce</a> (const Range &amp;range, Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gec1b7c03f9da909bef5db12e3d41bed3"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gec1b7c03f9da909bef5db12e3d41bed3" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gec1b7c03f9da909bef5db12e3d41bed3">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00193.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00193.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g18a19157e6245992fc00ca0adeb7dd37"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g18a19157e6245992fc00ca0adeb7dd37" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g18a19157e6245992fc00ca0adeb7dd37">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00146.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00146.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc61e73fcc36c92d79a217fc355ff4a6b"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gc61e73fcc36c92d79a217fc355ff4a6b" args="(const Range &amp;range, Body &amp;body, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gc61e73fcc36c92d79a217fc355ff4a6b">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00141.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00141.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g45cb00c42a18e334bbde8b7535afe460"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g45cb00c42a18e334bbde8b7535afe460" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g45cb00c42a18e334bbde8b7535afe460">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00193.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1c1ea1d7c61b3c225e92c70d669a53a5"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g1c1ea1d7c61b3c225e92c70d669a53a5" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g1c1ea1d7c61b3c225e92c70d669a53a5">parallel_reduce</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00146.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00146.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd9ac3a3811060314695f33b703c6e11b"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gd9ac3a3811060314695f33b703c6e11b" args="(const Range &amp;range, Body &amp;body, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gd9ac3a3811060314695f33b703c6e11b">parallel_reduce</a> (const Range &amp;range, Body &amp;body, <a class="el" href="a00141.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00141.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc9412e09fb01fcad8c018ea9cffb28ef"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gc9412e09fb01fcad8c018ea9cffb28ef" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gc9412e09fb01fcad8c018ea9cffb28ef">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gaddffeec0e892ac3d6fc7fc2053e1eca"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gaddffeec0e892ac3d6fc7fc2053e1eca" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gaddffeec0e892ac3d6fc7fc2053e1eca">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00193.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00193.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb175401f0729e40dd2c5860a17c14385"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gb175401f0729e40dd2c5860a17c14385" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gb175401f0729e40dd2c5860a17c14385">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00146.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00146.html">auto_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb7f1f1828ae2b330ce05b8513a495154"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gb7f1f1828ae2b330ce05b8513a495154" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, affinity_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gb7f1f1828ae2b330ce05b8513a495154">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00141.html">affinity_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction and <a class="el" href="a00141.html">affinity_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gfbc0cc2026d87f11a96bcd62788f5bb5"></a><!-- doxytag: member="tbb::parallel_reduce" ref="gfbc0cc2026d87f11a96bcd62788f5bb5" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const simple_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gfbc0cc2026d87f11a96bcd62788f5bb5">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00193.html">simple_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, simple partitioner and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g630c90a399937d9d4ae70ff883186dfd"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g630c90a399937d9d4ae70ff883186dfd" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const auto_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g630c90a399937d9d4ae70ff883186dfd">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, const <a class="el" href="a00146.html">auto_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00146.html">auto_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g496bd7eadb3b97495ccb5655ef90319e"></a><!-- doxytag: member="tbb::parallel_reduce" ref="g496bd7eadb3b97495ccb5655ef90319e" args="(const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, affinity_partitioner &amp;partitioner, task_group_context &amp;context)" -->
template&lt;typename Range, typename Value, typename RealBody, typename Reduction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Value&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g496bd7eadb3b97495ccb5655ef90319e">parallel_reduce</a> (const Range &amp;range, const Value &amp;identity, const RealBody &amp;real_body, const Reduction &amp;reduction, <a class="el" href="a00141.html">affinity_partitioner</a> &amp;partitioner, <a class="el" href="a00201.html">task_group_context</a> &amp;context)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel iteration with reduction, <a class="el" href="a00141.html">affinity_partitioner</a> and user-supplied context. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_scan</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="range_req.html">Range</a> and <a class="el" href="parallel_scan_body_req.html">parallel_scan Body</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ged143f31dd3d96ded02ab3db915b91c7"></a><!-- doxytag: member="tbb::parallel_scan" ref="ged143f31dd3d96ded02ab3db915b91c7" args="(const Range &amp;range, Body &amp;body)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#ged143f31dd3d96ded02ab3db915b91c7">parallel_scan</a> (const Range &amp;range, Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with default partitioner. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc9fac8870b2e6365fb337014404529df"></a><!-- doxytag: member="tbb::parallel_scan" ref="gc9fac8870b2e6365fb337014404529df" args="(const Range &amp;range, Body &amp;body, const simple_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gc9fac8870b2e6365fb337014404529df">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00193.html">simple_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00193.html">simple_partitioner</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g62fde400a37bbca1a2fddc8e3d22f556"></a><!-- doxytag: member="tbb::parallel_scan" ref="g62fde400a37bbca1a2fddc8e3d22f556" args="(const Range &amp;range, Body &amp;body, const auto_partitioner &amp;partitioner)" -->
template&lt;typename Range, typename Body&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g62fde400a37bbca1a2fddc8e3d22f556">parallel_scan</a> (const Range &amp;range, Body &amp;body, const <a class="el" href="a00146.html">auto_partitioner</a> &amp;partitioner)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel prefix with <a class="el" href="a00146.html">auto_partitioner</a>. <br></td></tr>
<tr><td colspan="2"><br><h2>parallel_sort</h2></td></tr>
<tr><td colspan="2">See also requirements on <a class="el" href="parallel_sort_iter_req.html">iterators for parallel_sort</a>. <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename Compare&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g49edcf9447cd91a9527a3f8e8512b7aa">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) using the given comparator.  <a href="a00274.html#g49edcf9447cd91a9527a3f8e8512b7aa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g16c3eb77d0e530834c51ce3857f01012"></a><!-- doxytag: member="tbb::parallel_sort" ref="g16c3eb77d0e530834c51ce3857f01012" args="(RandomAccessIterator begin, RandomAccessIterator end)" -->
template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g16c3eb77d0e530834c51ce3857f01012">parallel_sort</a> (RandomAccessIterator begin, RandomAccessIterator end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in [begin,end) with a default comparator <code>std::less&lt;RandomAccessIterator&gt;</code>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc7576f82fdedc8a701a6c17ad9415926"></a><!-- doxytag: member="tbb::parallel_sort" ref="gc7576f82fdedc8a701a6c17ad9415926" args="(T *begin, T *end)" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#gc7576f82fdedc8a701a6c17ad9415926">parallel_sort</a> (T *begin, T *end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the data in the range <code></code>[begin,end) with a default comparator <code>std::less&lt;T&gt;</code>. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf4486f36580f7d4bf95aed2e052a380"></a><!-- doxytag: member="tbb::critical_section" ref="bf4486f36580f7d4bf95aed2e052a380" args="" -->
typedef internal::critical_section_v4&nbsp;</td><td class="memItemRight" valign="bottom"><b>critical_section</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fdc2b067a243747d4c3dfe6f3d28476"></a><!-- doxytag: member="tbb::spin_rw_mutex" ref="7fdc2b067a243747d4c3dfe6f3d28476" args="" -->
typedef <a class="el" href="a00196.html">spin_rw_mutex_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>spin_rw_mutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3d457eb737199125df5ab0cf2f44094"></a><!-- doxytag: member="tbb::stack_size_type" ref="a3d457eb737199125df5ab0cf2f44094" args="" -->
typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>stack_size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ceb89493291d4b03ce5f062fbaac0653"></a><!-- doxytag: member="tbb::task_scheduler_observer" ref="ceb89493291d4b03ce5f062fbaac0653" args="" -->
typedef internal::task_scheduler_observer_v3&nbsp;</td><td class="memItemRight" valign="bottom"><b>task_scheduler_observer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ed375248ff6019a70ca0f9da528e5d0b"></a><!-- doxytag: member="tbb::assertion_handler_type" ref="ed375248ff6019a70ca0f9da528e5d0b" args="(const char *filename, int line, const char *expression, const char *comment)" -->
typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ed375248ff6019a70ca0f9da528e5d0b">assertion_handler_type</a> (const char *filename, int line, const char *expression, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type for an assertion handler. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#a8686246bb5d3664bd07563749970fef">memory_semantics</a> { <a class="el" href="a00267.html#a8686246bb5d3664bd07563749970fefc6db01678b1749dff7554688d079520c">__TBB_full_fence</a>, 
<a class="el" href="a00267.html#a8686246bb5d3664bd07563749970fef5f1fafe8d229d348ff91d937f64e79c7">acquire</a>, 
<a class="el" href="a00267.html#a8686246bb5d3664bd07563749970fefaa1fa107db0245c41fb109d976ae8d70">release</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specifies memory fencing.  <a href="a00267.html#a8686246bb5d3664bd07563749970fef">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#a8622ae61b7e7737dac26542e181178e">ets_key_usage_type</a> { <b>ets_key_per_instance</b>, 
<b>ets_no_key</b>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">enum for selecting between single key and key-per-instance versions <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>task_group_status</b> { <b>not_complete</b>, 
<b>complete</b>, 
<b>canceled</b>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e067bc86f20023cf3034f2ac310927b"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC" ref="2e067bc86f20023cf3034f2ac310927b" args="(__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>__TBB_DECL_ATOMIC</b> (__TBB_LONG_LONG) __TBB_DECL_ATOMIC(unsigned __TBB_LONG_LONG) __TBB_DECL_ATOMIC(long) __TBB_DECL_ATOMIC(unsigned long) __TBB_DECL_ATOMIC_ALT(unsigned</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad165cf61abbe349d413df2589679add"></a><!-- doxytag: member="tbb::__TBB_DECL_ATOMIC_ALT" ref="ad165cf61abbe349d413df2589679add" args="(int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct atomic&lt; T * &gt;" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#ad165cf61abbe349d413df2589679add">__TBB_DECL_ATOMIC_ALT</a> (int, ptrdiff_t) __TBB_DECL_ATOMIC(unsigned) __TBB_DECL_ATOMIC(int) __TBB_DECL_ATOMIC(unsigned short) __TBB_DECL_ATOMIC(short) __TBB_DECL_ATOMIC(char) __TBB_DECL_ATOMIC(signed char) __TBB_DECL_ATOMIC(unsigned char) __TBB_DECL_ATOMIC(wchar_t) template&lt; typename T &gt; struct <a class="el" href="a00143.html">atomic</a>&lt; T * &gt;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for atomic&lt;T*&gt; with arithmetic and operator-&gt;. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7af9509624a62ea848afe775f892ed12"></a><!-- doxytag: member="tbb::operator==" ref="7af9509624a62ea848afe775f892ed12" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00151.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00151.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="426abbf5243087148f5e3767e68c286b"></a><!-- doxytag: member="tbb::operator!=" ref="426abbf5243087148f5e3767e68c286b" args="(const cache_aligned_allocator&lt; T &gt; &amp;, const cache_aligned_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00151.html">cache_aligned_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00151.html">cache_aligned_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f3609fc523a99c101572fdc68f918d66"></a><!-- doxytag: member="tbb::operator==" ref="f3609fc523a99c101572fdc68f918d66" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00156.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00156.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="2da30ff86b9a39722f45bc35e1c6934d"></a><!-- doxytag: member="tbb::operator!=" ref="2da30ff86b9a39722f45bc35e1c6934d" args="(const concurrent_hash_map&lt; Key, T, HashCompare, A1 &gt; &amp;a, const concurrent_hash_map&lt; Key, T, HashCompare, A2 &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A1, typename A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00156.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A1 &gt; &amp;a, const <a class="el" href="a00156.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="817c20df80fe1a933a8557eb76113e24"></a><!-- doxytag: member="tbb::swap" ref="817c20df80fe1a933a8557eb76113e24" args="(concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;a, concurrent_hash_map&lt; Key, T, HashCompare, A &gt; &amp;b)" -->
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00156.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;a, <a class="el" href="a00156.html">concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="11419db87ac98110907dda08a24f0949"></a><!-- doxytag: member="tbb::operator==" ref="11419db87ac98110907dda08a24f0949" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="aa9e09f2e9154ffd6658fad8355fb491"></a><!-- doxytag: member="tbb::operator!=" ref="aa9e09f2e9154ffd6658fad8355fb491" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="33267dd805415351956d45b4b5347190"></a><!-- doxytag: member="tbb::operator&lt;" ref="33267dd805415351956d45b4b5347190" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="14e2968ab20cb714bef1f0352fc152f0"></a><!-- doxytag: member="tbb::operator&gt;" ref="14e2968ab20cb714bef1f0352fc152f0" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0042a36a670a397fb52e713edbaecd0e"></a><!-- doxytag: member="tbb::operator&lt;=" ref="0042a36a670a397fb52e713edbaecd0e" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f70eb1d931473b69ba4bcf93af8baa33"></a><!-- doxytag: member="tbb::operator&gt;=" ref="f70eb1d931473b69ba4bcf93af8baa33" args="(const concurrent_vector&lt; T, A1 &gt; &amp;a, const concurrent_vector&lt; T, A2 &gt; &amp;b)" -->
template&lt;typename T, class A1, class A2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A1 &gt; &amp;a, const <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="4a3897ea8d8a48e885d764bd7d370d50"></a><!-- doxytag: member="tbb::swap" ref="4a3897ea8d8a48e885d764bd7d370d50" args="(concurrent_vector&lt; T, A &gt; &amp;a, concurrent_vector&lt; T, A &gt; &amp;b)" -->
template&lt;typename T, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A &gt; &amp;a, <a class="el" href="a00162.html">concurrent_vector</a>&lt; T, A &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="906ebb461ecb0446989739fd0399e4b8"></a><!-- doxytag: member="tbb::operator==" ref="906ebb461ecb0446989739fd0399e4b8" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00191.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00191.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a92757aca0a69082eb8dc223eb257433"></a><!-- doxytag: member="tbb::operator!=" ref="a92757aca0a69082eb8dc223eb257433" args="(const scalable_allocator&lt; T &gt; &amp;, const scalable_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00191.html">scalable_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00191.html">scalable_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e2f5baabe173fbf48e94fb9058f1b41"></a><!-- doxytag: member="tbb::is_current_task_group_canceling" ref="7e2f5baabe173fbf48e94fb9058f1b41" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>is_current_task_group_canceling</b> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3bb9a8b837a9b7c4b5107caf01e81329"></a><!-- doxytag: member="tbb::make_task" ref="3bb9a8b837a9b7c4b5107caf01e81329" args="(const F &amp;f)" -->
template&lt;class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">task_handle&lt; F &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>make_task</b> (const F &amp;f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c8a46d6c0fe474eb399d0d09c27a4685"></a><!-- doxytag: member="tbb::operator==" ref="c8a46d6c0fe474eb399d0d09c27a4685" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00204.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00204.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3d9665c21c894f06f1614947103dc9d6"></a><!-- doxytag: member="tbb::operator!=" ref="3d9665c21c894f06f1614947103dc9d6" args="(const tbb_allocator&lt; T &gt; &amp;, const tbb_allocator&lt; U &gt; &amp;)" -->
template&lt;typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00204.html">tbb_allocator</a>&lt; T &gt; &amp;, const <a class="el" href="a00204.html">tbb_allocator</a>&lt; U &gt; &amp;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="b64fb7e52f0049b5a103cbb6fb5814f0"></a><!-- doxytag: member="tbb::operator==" ref="b64fb7e52f0049b5a103cbb6fb5814f0" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1, template&lt; typename X1 &gt; class B1, typename T2, template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00213.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00213.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ae43b5151d0220fe3ade0b447cd64f0d"></a><!-- doxytag: member="tbb::operator!=" ref="ae43b5151d0220fe3ade0b447cd64f0d" args="(const zero_allocator&lt; T1, B1 &gt; &amp;a, const zero_allocator&lt; T2, B2 &gt; &amp;b)" -->
template&lt;typename T1, template&lt; typename X1 &gt; class B1, typename T2, template&lt; typename X2 &gt; class B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00213.html">zero_allocator</a>&lt; T1, B1 &gt; &amp;a, const <a class="el" href="a00213.html">zero_allocator</a>&lt; T2, B2 &gt; &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="823fa1c15dd829d1d9167157450ddcd9"></a><!-- doxytag: member="tbb::set_assertion_handler" ref="823fa1c15dd829d1d9167157450ddcd9" args="(assertion_handler_type new_handler)" -->
<a class="el" href="a00267.html#ed375248ff6019a70ca0f9da528e5d0b">assertion_handler_type</a> __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#823fa1c15dd829d1d9167157450ddcd9">set_assertion_handler</a> (<a class="el" href="a00267.html#ed375248ff6019a70ca0f9da528e5d0b">assertion_handler_type</a> new_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set assertion handler and return previous value of it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#3d1252787be39b4aef311f1cadaff9e8">assertion_failure</a> (const char *filename, int line, const char *expression, const char *comment)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process an assertion failure.  <a href="#3d1252787be39b4aef311f1cadaff9e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int __TBB_EXPORTED_FUNC&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html#a6858b22e90041c9c4669674ff39b056">TBB_runtime_interface_version</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function returns the interface version of the TBB shared library being used.  <a href="#a6858b22e90041c9c4669674ff39b056"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a42aa5dbcf06ba86c71efb73d8311c3"></a><!-- doxytag: member="tbb::operator-" ref="6a42aa5dbcf06ba86c71efb73d8311c3" args="(const tick_count &amp;t1, const tick_count &amp;t0)" -->
<a class="el" href="a00211.html">tick_count::interval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00210.html">tick_count</a> &amp;t1, const <a class="el" href="a00210.html">tick_count</a> &amp;t0)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The namespace tbb contains all components of the library. <hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a8686246bb5d3664bd07563749970fef"></a><!-- doxytag: member="tbb::memory_semantics" ref="a8686246bb5d3664bd07563749970fef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00267.html#a8686246bb5d3664bd07563749970fef">tbb::memory_semantics</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies memory fencing. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a8686246bb5d3664bd07563749970fefc6db01678b1749dff7554688d079520c"></a><!-- doxytag: member="__TBB_full_fence" ref="a8686246bb5d3664bd07563749970fefc6db01678b1749dff7554688d079520c" args="" -->__TBB_full_fence</em>&nbsp;</td><td>
For internal use only. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a8686246bb5d3664bd07563749970fef5f1fafe8d229d348ff91d937f64e79c7"></a><!-- doxytag: member="acquire" ref="a8686246bb5d3664bd07563749970fef5f1fafe8d229d348ff91d937f64e79c7" args="" -->acquire</em>&nbsp;</td><td>
Acquire fence. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a8686246bb5d3664bd07563749970fefaa1fa107db0245c41fb109d976ae8d70"></a><!-- doxytag: member="release" ref="a8686246bb5d3664bd07563749970fefaa1fa107db0245c41fb109d976ae8d70" args="" -->release</em>&nbsp;</td><td>
Release fence. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="3d1252787be39b4aef311f1cadaff9e8"></a><!-- doxytag: member="tbb::assertion_failure" ref="3d1252787be39b4aef311f1cadaff9e8" args="(const char *filename, int line, const char *expression, const char *comment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __TBB_EXPORTED_FUNC tbb::assertion_failure           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>comment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process an assertion failure. 
<p>
Normally called from __TBB_ASSERT macro. If assertion handler is null, print message for assertion failure and abort. Otherwise call the assertion handler. 
</div>
</div><p>
<a class="anchor" name="a6858b22e90041c9c4669674ff39b056"></a><!-- doxytag: member="tbb::TBB_runtime_interface_version" ref="a6858b22e90041c9c4669674ff39b056" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __TBB_EXPORTED_FUNC tbb::TBB_runtime_interface_version           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the interface version of the TBB shared library being used. 
<p>
The version it returns is determined at runtime, not at compile/link time. So it can be different than the value of TBB_INTERFACE_VERSION obtained at compile time. 
</div>
</div><p>
<hr>
<p></p>
Copyright &copy; 2005-2010 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
