<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::interface4::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="a00267.html">tbb</a>::<b>interface4</b>::<a class="el" href="a00156.html">concurrent_hash_map</a></div>
<h1>tbb::interface4::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00275.html">Containers</a>]</small>
</h1><!-- doxytag: class="tbb::interface4::concurrent_hash_map" -->Unordered map from Key to T.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="a00325.html">concurrent_hash_map.h</a>&gt;</code>
<p>
<a href="a00013.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="33b3b94e17dab45c97b246bca3625655"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::key_type" ref="33b3b94e17dab45c97b246bca3625655" args="" -->
typedef Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5d75ef053d5e69de88ae7e941a743ec"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::mapped_type" ref="a5d75ef053d5e69de88ae7e941a743ec" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01ebd1df398d3823ca6ea8fcb6b068ae"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::value_type" ref="01ebd1df398d3823ca6ea8fcb6b068ae" args="" -->
typedef std::pair&lt; const Key,<br>
 T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae6bb63bc9cf97d63e78d208ae0e479d"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::size_type" ref="ae6bb63bc9cf97d63e78d208ae0e479d" args="" -->
typedef hash_map_base::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f5093a93592b0a30fda935711f9f788"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::difference_type" ref="2f5093a93592b0a30fda935711f9f788" args="" -->
typedef ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d1ffb83cae339007dc8d5b2e4e3cea8"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::pointer" ref="1d1ffb83cae339007dc8d5b2e4e3cea8" args="" -->
typedef value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ecf3dc1d6d8290a71639967ffa933343"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::const_pointer" ref="ecf3dc1d6d8290a71639967ffa933343" args="" -->
typedef const value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14a3d74308b04a355b0689eb019ee683"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::reference" ref="14a3d74308b04a355b0689eb019ee683" args="" -->
typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f6fcb68889829bca708d57f7b9e2da4"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::const_reference" ref="1f6fcb68889829bca708d57f7b9e2da4" args="" -->
typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="118b95ebef79ac195fb99babbf335e8c"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::iterator" ref="118b95ebef79ac195fb99babbf335e8c" args="" -->
typedef internal::hash_map_iterator&lt;<br>
 <a class="el" href="a00156.html">concurrent_hash_map</a>, value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fec1af5576448740eb5c6119a30c6a9"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::const_iterator" ref="5fec1af5576448740eb5c6119a30c6a9" args="" -->
typedef internal::hash_map_iterator&lt;<br>
 <a class="el" href="a00156.html">concurrent_hash_map</a>, const <br>
value_type &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa3d1bdabd5e9a15174624946048a2c8"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::range_type" ref="aa3d1bdabd5e9a15174624946048a2c8" args="" -->
typedef internal::hash_map_range&lt;<br>
 iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="20981e8295ff79f4e3d8b76a16c42851"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::const_range_type" ref="20981e8295ff79f4e3d8b76a16c42851" args="" -->
typedef internal::hash_map_range&lt;<br>
 const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_range_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8d6e7e809e96f48fd039a54fc4df630"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::allocator_type" ref="f8d6e7e809e96f48fd039a54fc4df630" args="" -->
typedef Allocator&nbsp;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d827bb5e4f61de1916ab67d51c7c6e60"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::concurrent_hash_map" ref="d827bb5e4f61de1916ab67d51c7c6e60" args="(const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#d827bb5e4f61de1916ab67d51c7c6e60">concurrent_hash_map</a> (const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4612d5c7233712d455496641e9b31ff"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::concurrent_hash_map" ref="a4612d5c7233712d455496641e9b31ff" args="(size_type n, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a4612d5c7233712d455496641e9b31ff">concurrent_hash_map</a> (size_type n, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct empty table with n preallocated buckets. This number serves also as initial concurrency level. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="df0cd14eaddb17f10929c91519e65be9"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::concurrent_hash_map" ref="df0cd14eaddb17f10929c91519e65be9" args="(const concurrent_hash_map &amp;table, const allocator_type &amp;a=allocator_type())" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#df0cd14eaddb17f10929c91519e65be9">concurrent_hash_map</a> (const <a class="el" href="a00156.html">concurrent_hash_map</a> &amp;table, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="3bfe75fcb350ce39cf610c164f233edc"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::concurrent_hash_map" ref="3bfe75fcb350ce39cf610c164f233edc" args="(I first, I last, const allocator_type &amp;a=allocator_type())" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#3bfe75fcb350ce39cf610c164f233edc">concurrent_hash_map</a> (I first, I last, const allocator_type &amp;a=allocator_type())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c0c42a2e1b5282b6739157df9ce2304"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::operator=" ref="2c0c42a2e1b5282b6739157df9ce2304" args="(const concurrent_hash_map &amp;table)" -->
<a class="el" href="a00156.html">concurrent_hash_map</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#2c0c42a2e1b5282b6739157df9ce2304">operator=</a> (const <a class="el" href="a00156.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#13f3f2e8de7564be03882c31559493c9">rehash</a> (size_type n=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rehashes and optionally resizes the whole table.  <a href="#13f3f2e8de7564be03882c31559493c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9f89be8fe28835749529d91081a2511"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::clear" ref="a9f89be8fe28835749529d91081a2511" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a9f89be8fe28835749529d91081a2511">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1ac58997d8fbf242b266e3691573481"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::~concurrent_hash_map" ref="a1ac58997d8fbf242b266e3691573481" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a1ac58997d8fbf242b266e3691573481">~concurrent_hash_map</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear table and destroy it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d279026ce93bbef47a5b8a028cd387b"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::range" ref="1d279026ce93bbef47a5b8a028cd387b" args="(size_type grainsize=1)" -->
range_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="728c7aef8f1326f3f9ca6b4a6d1155cf"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::range" ref="728c7aef8f1326f3f9ca6b4a6d1155cf" args="(size_type grainsize=1) const " -->
const_range_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a3c58cf1234b74ca796dcf555d32f53"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::begin" ref="4a3c58cf1234b74ca796dcf555d32f53" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="28c690486d8db5783475f5b1a59d21bc"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::end" ref="28c690486d8db5783475f5b1a59d21bc" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa51c059c92aaf259916be74b928adb2"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::begin" ref="aa51c059c92aaf259916be74b928adb2" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2610bf00a3f631719308bdb59876f08"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::end" ref="d2610bf00a3f631719308bdb59876f08" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5faacd9a290b122947a21f72c676a0b9"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::equal_range" ref="5faacd9a290b122947a21f72c676a0b9" args="(const Key &amp;key)" -->
std::pair&lt; iterator, iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4abad08a1788b57a78698f16fab92838"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::equal_range" ref="4abad08a1788b57a78698f16fab92838" args="(const Key &amp;key) const " -->
std::pair&lt; const_iterator,<br>
 const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17fd8c5fe8c6a86075f34aa4e8412ba3"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::size" ref="17fd8c5fe8c6a86075f34aa4e8412ba3" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#17fd8c5fe8c6a86075f34aa4e8412ba3">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of items in table. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6cab7d029a3e73a653ef0faeac4d1586"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::empty" ref="6cab7d029a3e73a653ef0faeac4d1586" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#6cab7d029a3e73a653ef0faeac4d1586">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if <a class="el" href="a00156.html#17fd8c5fe8c6a86075f34aa4e8412ba3">size()</a>==0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e45d3cbd1e2ae06f365f1b48e0df0b5"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::max_size" ref="1e45d3cbd1e2ae06f365f1b48e0df0b5" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#1e45d3cbd1e2ae06f365f1b48e0df0b5">max_size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Upper bound on size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="414d15033d36c63aa3a40666dc4d6f5e"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::bucket_count" ref="414d15033d36c63aa3a40666dc4d6f5e" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#414d15033d36c63aa3a40666dc4d6f5e">bucket_count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current number of buckets. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="199208eed6f09e200cda364f906be0fe"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::get_allocator" ref="199208eed6f09e200cda364f906be0fe" args="() const " -->
allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#199208eed6f09e200cda364f906be0fe">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return allocator object <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eddb0d2efe0b4f25a85c059e1c3dac15"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::swap" ref="eddb0d2efe0b4f25a85c059e1c3dac15" args="(concurrent_hash_map &amp;table)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#eddb0d2efe0b4f25a85c059e1c3dac15">swap</a> (<a class="el" href="a00156.html">concurrent_hash_map</a> &amp;table)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">swap two instances. Iterators are invalidated <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74f5ef06a06c5e619f156a1c76c04969"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::count" ref="74f5ef06a06c5e619f156a1c76c04969" args="(const Key &amp;key) const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#74f5ef06a06c5e619f156a1c76c04969">count</a> (const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return count of items (0 or 1). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#64338d7f2e35df586af4cb0145cd910f">find</a> (<a class="el" href="a00159.html">const_accessor</a> &amp;result, const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a read lock on the item.  <a href="#64338d7f2e35df586af4cb0145cd910f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#bce7bdf46435115a95cca2aa73c5da83">find</a> (<a class="el" href="a00157.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find item and acquire a write lock on the item.  <a href="#bce7bdf46435115a95cca2aa73c5da83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#58c38b27273de6c670568633c0931854">insert</a> (<a class="el" href="a00159.html">const_accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a read lock on the item.  <a href="#58c38b27273de6c670568633c0931854"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#ccfecaa3e71d92be61fb3d811dd264eb">insert</a> (<a class="el" href="a00157.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item (if not already present) and acquire a write lock on the item.  <a href="#ccfecaa3e71d92be61fb3d811dd264eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#d4a2816129e38c53128c6d0c7b6b7370">insert</a> (<a class="el" href="a00159.html">const_accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="#d4a2816129e38c53128c6d0c7b6b7370"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#a657e61cd2b13164764ca2708875784a">insert</a> (<a class="el" href="a00157.html">accessor</a> &amp;result, const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="#a657e61cd2b13164764ca2708875784a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#52bffd1066b3d7b793945bc6fa1a71a1">insert</a> (const value_type &amp;value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="#52bffd1066b3d7b793945bc6fa1a71a1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="cfe172677e5987004ef4a03e22fa338a"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::insert" ref="cfe172677e5987004ef4a03e22fa338a" args="(I first, I last)" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#cfe172677e5987004ef4a03e22fa338a">insert</a> (I first, I last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert range [first, last). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#034c3b3ee419edee78e0f2f2b1f0d7ca">erase</a> (const Key &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item.  <a href="#034c3b3ee419edee78e0f2f2b1f0d7ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#da7e4a50f6bb06191817425ec85fe760">erase</a> (<a class="el" href="a00159.html">const_accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by <a class="el" href="a00159.html">const_accessor</a>.  <a href="#da7e4a50f6bb06191817425ec85fe760"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#0f500842d0cf791f8fa61662edb1b311">erase</a> (<a class="el" href="a00157.html">accessor</a> &amp;item_accessor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase item by accessor.  <a href="#0f500842d0cf791f8fa61662edb1b311"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6bea55a4e94be2ab299de06dc266f3a3"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::node_allocator_type" ref="6bea55a4e94be2ab299de06dc266f3a3" args="" -->
typedef Allocator::template <br>
rebind&lt; node &gt;::other&nbsp;</td><td class="memItemRight" valign="bottom"><b>node_allocator_type</b></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53a98a10a2adb33d91a286a487d0cd78"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::delete_node" ref="53a98a10a2adb33d91a286a487d0cd78" args="(node_base *n)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>delete_node</b> (node_base *n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d30c4c2698ea07ed6dd0e9eaf774b11"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::search_bucket" ref="6d30c4c2698ea07ed6dd0e9eaf774b11" args="(const key_type &amp;key, bucket *b) const " -->
node *&nbsp;</td><td class="memItemRight" valign="bottom"><b>search_bucket</b> (const key_type &amp;key, bucket *b) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="571d635fd206d9985cf20a1a659ea476"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::rehash_bucket" ref="571d635fd206d9985cf20a1a659ea476" args="(bucket *b_new, const hashcode_t h)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rehash_bucket</b> (bucket *b_new, const hashcode_t h)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1f22480a290ddc6c145888d8f985531a"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::lookup" ref="1f22480a290ddc6c145888d8f985531a" args="(bool op_insert, const Key &amp;key, const T *t, const_accessor *result, bool write)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#1f22480a290ddc6c145888d8f985531a">lookup</a> (bool op_insert, const Key &amp;key, const T *t, <a class="el" href="a00159.html">const_accessor</a> *result, bool write)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert or find item and optionally acquire a lock on the item. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="faad2108bd2be75e52293486af59f11e"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::exclude" ref="faad2108bd2be75e52293486af59f11e" args="(const_accessor &amp;item_accessor, bool readonly)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#faad2108bd2be75e52293486af59f11e">exclude</a> (<a class="el" href="a00159.html">const_accessor</a> &amp;item_accessor, bool readonly)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">delete item by accessor <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="976c57edfb7f22b9f91a2e11f141eb4a"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::internal_equal_range" ref="976c57edfb7f22b9f91a2e11f141eb4a" args="(const Key &amp;key, I end) const " -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; I, I &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00156.html#976c57edfb7f22b9f91a2e11f141eb4a">internal_equal_range</a> (const Key &amp;key, I end) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator for an item defined by the key, or for the next item after it (if upper==true). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3c27779fe66b79505390d084310d997e"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::internal_copy" ref="3c27779fe66b79505390d084310d997e" args="(const concurrent_hash_map &amp;source)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#3c27779fe66b79505390d084310d997e">internal_copy</a> (const <a class="el" href="a00156.html">concurrent_hash_map</a> &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy "source" to *this, where *this must start out empty. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="cf43170691e36146a1bff61e3cf895ce"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::internal_copy" ref="cf43170691e36146a1bff61e3cf895ce" args="(I first, I last)" -->
template&lt;typename I&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>internal_copy</b> (I first, I last)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html#2f76ed101a0ccc8875b846c2f747897e">internal_fast_find</a> (const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast find when no concurrent erasure is used. For internal use inside TBB only!  <a href="#2f76ed101a0ccc8875b846c2f747897e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="252e91d8029f6308db7179557e3b1436"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::my_allocator" ref="252e91d8029f6308db7179557e3b1436" args="" -->
node_allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>my_allocator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f738f241c8500ce3dbf0f9028ca8b602"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::my_hash_compare" ref="f738f241c8500ce3dbf0f9028ca8b602" args="" -->
HashCompare&nbsp;</td><td class="memItemRight" valign="bottom"><b>my_hash_compare</b></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e24acd2f6849db3377a3942807639758"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::internal::hash_map_iterator" ref="e24acd2f6849db3377a3942807639758" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c94f21746c8902f7e0b5115a8d4da1d2"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::internal::hash_map_range" ref="c94f21746c8902f7e0b5115a8d4da1d2" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>internal::hash_map_range</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c0028dfa75a6baa14007355ab1ef7fc"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::const_accessor" ref="2c0028dfa75a6baa14007355ab1ef7fc" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_accessor</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows write access to elements and combines data access, locking, and garbage collection.  <a href="a00157.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">bucket_accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bucket accessor is to find, rehash, acquire a lock, and access a bucket  <a href="a00158.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">const_accessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines data access, locking, and garbage collection.  <a href="a00159.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt;<br>
 class tbb::interface4::concurrent_hash_map&lt; Key, T, HashCompare, Allocator &gt;</h3>

Unordered map from Key to T. 
<p>
<a class="el" href="a00156.html">concurrent_hash_map</a> is associative container with concurrent access.<p>
<dl compact><dt><b>Compatibility</b></dt><dd>The class meets all Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1).</dd></dl>
<dl compact><dt><b>Exception Safety</b></dt><dd><ul>
<li>Hash function is not permitted to throw an exception. User-defined types Key and T are forbidden from throwing an exception in destructors.</li><li>If exception happens during <a class="el" href="a00156.html#58c38b27273de6c670568633c0931854">insert()</a> operations, it has no effect (unless exception raised by HashCompare::hash() function during grow_segment).</li><li>If exception happens during <a class="el" href="a00156.html#2c0c42a2e1b5282b6739157df9ce2304">operator=()</a> operation, the container can have a part of source items, and methods <a class="el" href="a00156.html#17fd8c5fe8c6a86075f34aa4e8412ba3">size()</a> and <a class="el" href="a00156.html#6cab7d029a3e73a653ef0faeac4d1586">empty()</a> can return wrong results.</li></ul>
</dd></dl>
<dl compact><dt><b>Changes since TBB 2.1</b></dt><dd><ul>
<li>Replaced internal algorithm and data structure. Patent is pending.</li><li>Added buckets number argument for constructor</li></ul>
</dd></dl>
<dl compact><dt><b>Changes since TBB 2.0</b></dt><dd><ul>
<li>Fixed exception-safety</li><li>Added template argument for allocator</li><li>Added allocator argument in constructors</li><li>Added constructor from a range of iterators</li><li>Added several new overloaded <a class="el" href="a00156.html#58c38b27273de6c670568633c0931854">insert()</a> methods</li><li>Added <a class="el" href="a00156.html#199208eed6f09e200cda364f906be0fe">get_allocator()</a></li><li>Added <a class="el" href="a00156.html#eddb0d2efe0b4f25a85c059e1c3dac15">swap()</a></li><li>Added <a class="el" href="a00156.html#74f5ef06a06c5e619f156a1c76c04969">count()</a></li><li>Added overloaded <a class="el" href="a00156.html#0f500842d0cf791f8fa61662edb1b311">erase(accessor &amp;)</a> and <a class="el" href="a00156.html#da7e4a50f6bb06191817425ec85fe760">erase(const_accessor&amp;)</a></li><li>Added equal_range() [const]</li><li>Added [const_]pointer, [const_]reference, and allocator_type types</li><li>Added global functions: operator==(), operator!=(), and <a class="el" href="a00156.html#eddb0d2efe0b4f25a85c059e1c3dac15">swap()</a> </li></ul>
</dd></dl>

<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0f500842d0cf791f8fa61662edb1b311"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::erase" ref="0f500842d0cf791f8fa61662edb1b311" args="(accessor &amp;item_accessor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00157.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item_accessor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item by accessor. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="da7e4a50f6bb06191817425ec85fe760"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::erase" ref="da7e4a50f6bb06191817425ec85fe760" args="(const_accessor &amp;item_accessor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00159.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item_accessor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item by <a class="el" href="a00159.html">const_accessor</a>. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="034c3b3ee419edee78e0f2f2b1f0d7ca"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::erase" ref="034c3b3ee419edee78e0f2f2b1f0d7ca" args="(const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase           </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase item. 
<p>
Return true if item was erased by particularly this call. 
</div>
</div><p>
<a class="anchor" name="bce7bdf46435115a95cca2aa73c5da83"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::find" ref="bce7bdf46435115a95cca2aa73c5da83" args="(accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00157.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find item and acquire a write lock on the item. 
<p>
Return true if item is found, false otherwise. 
</div>
</div><p>
<a class="anchor" name="64338d7f2e35df586af4cb0145cd910f"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::find" ref="64338d7f2e35df586af4cb0145cd910f" args="(const_accessor &amp;result, const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00159.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find item and acquire a read lock on the item. 
<p>
Return true if item is found, false otherwise. 
</div>
</div><p>
<a class="anchor" name="52bffd1066b3d7b793945bc6fa1a71a1"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::insert" ref="52bffd1066b3d7b793945bc6fa1a71a1" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already. 
<p>
Returns true if item is inserted. 
</div>
</div><p>
<a class="anchor" name="a657e61cd2b13164764ca2708875784a"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::insert" ref="a657e61cd2b13164764ca2708875784a" args="(accessor &amp;result, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00157.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already and acquire a write lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="d4a2816129e38c53128c6d0c7b6b7370"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::insert" ref="d4a2816129e38c53128c6d0c7b6b7370" args="(const_accessor &amp;result, const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00159.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item by copying if there is no such key present already and acquire a read lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="ccfecaa3e71d92be61fb3d811dd264eb"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::insert" ref="ccfecaa3e71d92be61fb3d811dd264eb" args="(accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00157.html">accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item (if not already present) and acquire a write lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="58c38b27273de6c670568633c0931854"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::insert" ref="58c38b27273de6c670568633c0931854" args="(const_accessor &amp;result, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00159.html">const_accessor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert item (if not already present) and acquire a read lock on the item. 
<p>
Returns true if item is new. 
</div>
</div><p>
<a class="anchor" name="2f76ed101a0ccc8875b846c2f747897e"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::internal_fast_find" ref="2f76ed101a0ccc8875b846c2f747897e" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, Allocator &gt;::internal_fast_find           </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fast find when no concurrent erasure is used. For internal use inside TBB only! 
<p>
Return pointer to item with given key, or NULL if no such item exists. Must not be called concurrently with erasure operations. 
</div>
</div><p>
<a class="anchor" name="13f3f2e8de7564be03882c31559493c9"></a><!-- doxytag: member="tbb::interface4::concurrent_hash_map::rehash" ref="13f3f2e8de7564be03882c31559493c9" args="(size_type n=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key, typename T, typename HashCompare, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00156.html">tbb::interface4::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::rehash           </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rehashes and optionally resizes the whole table. 
<p>
Useful to optimize performance before or after concurrent operations. Also enables using of <a class="el" href="a00156.html#64338d7f2e35df586af4cb0145cd910f">find()</a> and <a class="el" href="a00156.html#74f5ef06a06c5e619f156a1c76c04969">count()</a> concurrent methods in serial context. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00325.html">concurrent_hash_map.h</a></ul>
<hr>
<p></p>
Copyright &copy; 2005-2010 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
